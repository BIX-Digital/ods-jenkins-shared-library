Triggers (and follows) a rollout of the `DeploymentConfig` related to the repository
being built.

It achieves this by tagging the image built in `odsComponentStageBuildOpenShiftImage` with `latest`. This might already trigger a rollout based on an existing `ImageTrigger`. If none is set, the stage will start a manual rollout.

If the directory referenced by `openshiftDir` exists, the templates in there will be applied using https://github.com/opendevstack/tailor[Tailor]. In this case, it is recommended to remove any image triggers to avoid duplicate rollouts (one when configuration changes due to a config trigger and one when the image is tagged to `latest`). In addition to the configuration options below, one can use e.g. a `Tailorfile` to adjust the behaviour of Tailor as needed.

Available options:

[cols="1,2"]
|===
| Option | Description

| selector
| Selector scope used to determine which resources are part of a component (defaults to `context.selector`).

| imageTag
| Image tag on which to apply the `latest` tag (defaults to `context.shortGitCommit`).

| deployTimeoutMinutes
| Adjust timeout of rollout (defaults to 5 minutes). Caution: This needs to be aligned with the deployment strategy timeout (timeoutSeconds) and the readiness probe timeouts (initialDelaySeconds + failureThreshold * periodSeconds).

| deployTimeoutRetries
| Adjust retries to wait for the pod during a rollout (defaults to 5). 

| chartDir
| Directory of Helm chart (defaults to `chart`).

| helmReleaseName
| Name of the Helm release (defaults to `context.componentId`). Change this value if you want to install separate instances of the Helm chart in the same namespace. In that case, make sure to use `{{ .Release.Name }}` in resource names to avoid conflicts.  Only relevant if the directory referenced by `chartDir` exists.

| helmValues
| Map of key/value pairs to pass as values (by default, the key `imageTag` is set to the config option `imageTag`). Only relevant if the directory referenced by `chartDir` exists.

| helmValuesFiles
| List of paths to values files (empty by default). Only relevant if the directory referenced by `chartDir` exists.

| helmDefaultFlags
| List of default flags to be passed verbatim to to `helm upgrade` (defaults to `['--install', '--atomic']`). Typically these should not be modified - if you want to pass more flags, use `helmAdditionalFlags` instead. Only relevant if the directory referenced by `chartDir` exists.

| helmAdditionalFlags
| List of additional flags to be passed verbatim to to `helm upgrade` (empty by default). Only relevant if the directory referenced by `chartDir` exists.

| helmDiff
| Whether to show diff explaining changes to the release before running `helm upgrade` (`true` by default). Only relevant if the directory referenced by `chartDir` exists.

| helmPrivateKeyCredentialsId
| Credentials name of the private key used by helm-secrets (defaults to `<PROJECT>-cd-helm-private-key`). The fingerprint must match the one specified in `.sops.yaml`. Only relevant if the directory referenced by `chartDir` exists.

| openshiftDir
| Directory with OpenShift templates (defaults to `openshift`).

| tailorPrivateKeyCredentialsId
| Credentials name of the private key used by Tailor (defaults to `<PROJECT>-cd-tailor-private-key`). Only relevant if the directory referenced by `openshiftDir` exists.

| tailorSelector
| Selector scope used by Tailor (defaults to config option `selector`). Only relevant if the directory referenced by `openshiftDir` exists.

| tailorVerify
| Whether Tailor verifies the live configuration against the desired state after application (defaults to `false`). Only relevant if the directory referenced by `openshiftDir` exists.

| tailorExclude
| Resource kind exclusion used by Tailor (defaults to `bc,is`). Only relevant if the directory referenced by `openshiftDir` exists.

| tailorParamFile
| Path to Tailor parameter file (defaults to none). Only relevant if the directory referenced by `openshiftDir` exists.

| tailorPreserve
| Paths to preserve in the live configuration (defaults to `[]`). Only relevant if the directory referenced by `openshiftDir` exists.

| tailorParams
| Additional parameters to pass to Tailor (defaults to `[]`). Only relevant if the directory referenced by `openshiftDir` exists.

| environmentsConfigMap
| Name of a `ConfigMap` within the `*-cd` namespace which defines the target projects of a conceptual environment. See the examples below.
|===

By default, a rollout happens in the OpenShift project identified by `context.targetProject`. This is constructed from `context.projectId` and `context.environment` (which is selected based on the `branchToEnvironmentMapping` configuration in your `Jenkinsfile`). With the `environmentsConfigMap` option, it is possible to specify explicitly which target projects rollout should happen in for the selected environment. This allows you to deploy into a namespace with a custom name, to deploy into multiple namespaces within one cluster, and into namespaces across different clusters.

Example:

`Jenkinsfile`
[source,groovy]
----
@Library('ods-jenkins-shared-library@latest') _
odsComponentPipeline(
  imageStreamTag: 'ods/jenkins-agent-base:latest',
  branchToEnvironmentMapping: [
    'master': 'dev',
    'release/': 'test'
  ]
) { context ->
  odsComponentFindOpenShiftImageOrElse(context) {
    odsComponentStageBuildOpenShiftImage(context)
  }
  odsComponentStageRolloutOpenShiftDeployment(context, [environmentsConfigMap: 'ods-environments'])
}
----

`ConfigMap` `ods-environments`
[source,yaml]
----
data:
  dev: |-
    local:
      namespace: foo-dev
  test: |-
    local-qa:
      namespace: foo-test
    local-uat:
      namespace: foo-uat
    aro:
      namespace: foo-test
      apiUrl: https://api.a3pqde7f.westeurope.aroapp.io:6443
      apiCredentialsSecret: aro-api
      registryHost: image-registry.apps.a3pqde7f.westeurope.aroapp.io
----

A push into branch `master` would select the `dev` environment, which is configured to deploy into the logical target named `local`. This name can be chosen freely - it is only used as an identifier and can be consumed as the environment variable `TARGET` e.g. when specifying parameter files. This logical target resolves to the specific namespace `foo-dev`. As there is no further configuration for this target, it is assumed that the namespace is on the same cluster as the Jenkins pipeline, and that the `jenkins` serviceaccount running the pipeline has enough rights to administrate resources in `foo-dev` (which is the default setup in ODS).

A push into branch `release/something` would select the `test` environment, which triggers three rollouts. One for the target `local-qa` into the namespace `foo-test`, one for the target `local-uat` into the namespace `foo-uat`, and one for the target `aro` into the namespace `foo-test`. Note that the first two rollouts are on the same cluster, while the `aro` target is on an external cluster. For Jenkins to be able to deploy there, you need to supply the following configuration:

* `apiUrl`: the OpenShift API of the external cluster (including scheme and port if applicable)
* `apiCredentialsSecret`: the name of a `Secret` of type `kubernetes.io/basic-auth` in the local `foo-cd` namespace, which holds the credentials of a `ServiceAccount` with `admin` permissions in the target project. The serviceaccount can be setup via `oc create sa ${name} && oc policy add-role-to-user admin system:serviceaccount:${project}:${name}`.
* `registryHost`: To transport images from the local `foo-cd` namespace to the external registry, you need to configure the (external!) hostname of your OpenShift registry where you want to push images to. The source and destination credentials are automatically retrieved from the `jenkins` serviceaccount in the source project and the `builder` serviceaccount in the target project. If you want to use a different secret for the target instead, you may set `registrySecret` pointing to a Secret in the target project of either type `kubernetes.io/dockercfg` or `kubernetes.io/dockerconfigjson`. The image push is implemented via https://github.com/containers/skopeo[skopeo]. Additional flags can be passed verbatim to the `skopeo` binary by specifying `skopeoAdditionalFlags`, e.g. `['--src-tls-verify=false', '--dest-tls-verify=false']`.

CAUTION: Deploying to new targets requires that your repository defines the Kubernetes resources. Otherwise the target project is empty and no deployment can be triggered.
